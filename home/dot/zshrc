# The following lines were added by compinstall

zstyle ':completion:*' auto-description 'specify: %d'
zstyle ':completion:*' completer _expand _complete _ignored _correct _approximate
zstyle ':completion:*' completions 1
zstyle ':completion:*' format 'Completing %d'
zstyle ':completion:*' glob 1
zstyle ':completion:*' group-name ''
zstyle ':completion:*' insert-unambiguous true
zstyle ':completion:*' list-colors ''
zstyle ':completion:*' list-prompt %SAt %p: Hit TAB for more, or the character to insert%s
zstyle ':completion:*' matcher-list 'm:{[:lower:]}={[:upper:]}' 'r:|[._-]=* r:|=*' 'l:|=* r:|=*'
zstyle ':completion:*' max-errors 2
zstyle ':completion:*' menu select=1
zstyle ':completion:*' original false
zstyle ':completion:*' select-prompt %SScrolling active: current selection at %p%s
zstyle ':completion:*' substitute 1
zstyle ':completion:*' verbose false
zstyle :compinstall filename '/Users/gary/.zshrc'

autoload -Uz compinit
compinit
# End of lines added by compinstall
# Lines configured by zsh-newuser-install
HISTFILE=~/.histfile
HISTSIZE=1000000
SAVEHIST=1000000
setopt INC_APPEND_HISTORY_TIME noautocd beep extendedglob nomatch
unsetopt notify
# vi mode
bindkey -v
bindkey -M vicmd "/" history-incremental-pattern-search-backward
bindkey -M vicmd "?" history-incremental-pattern-search-forward
# End of lines configured by zsh-newuser-install

unsetopt sharehistory
bindkey '^?' backward-delete-char
autoload history-search-end
zle -N history-beginning-search-backward-end \
    history-search-end
zle -N history-beginning-search-forward-end \
    history-search-end
bindkey '^[[A' history-beginning-search-backward-end
bindkey '^[[B' history-beginning-search-forward-end

setopt incappendhistory histignorealldups histfindnodups histignorespace

autoload -U colors
colors

foreach cmd (locate find wget)
    alias $cmd="noglob $cmd"
end

function box_name {
    [ -f ~/.box-name ] && cat ~/.box-name || hostname -s
}

setopt PROMPT_SUBST
PROMPT=$'%{$fg[green]%}[%T]%{$reset_color%}%{$fg_bold[green]%}%n%{$reset_color%}@%{$fg[yellow]%}$(box_name)%{$reset_color%}:%{$fg_bold[blue]%}%~%{$reset_color%}
$ '

eval "$($HOME/.env_vars)"
alias ls="ls --color=auto"
alias grep="grep --color=auto"

# ensure compatibility tmux <-> direnv
if [ -n "$TMUX" ] && [ -n "$DIRENV_DIR" ]; then
  for e in $(env | grep -i direnv | sed 's/\([^=]*\)=.*/\1/'); do
    unset $e
  done
fi
eval "$(direnv hook zsh)"

gc() {
  local branch sha
  branch=$1
  sha=$(git rev-parse $branch)
  ref=${2:-main}
  if [ -z "$(git status --porcelain)" ]; then
    git checkout $ref
    git pull
    git checkout $branch
    git reset --soft $(git merge-base HEAD $ref)
    git commit -m "replace with $sha"
    if git rebase $ref; then
      if git diff --exit-code $ref >/dev/null; then
        git checkout $ref
        git branch -d $branch
        echo "Branch deleted; remaining branches:"
        git branch
      else
        echo "Branch rebases cleanly, but has unmerged changes"
        git reset --hard $sha
        git checkout $ref
        echo "Remaining branches:"
        git branch
      fi
    else
      git rebase --abort
      git checkout $branch
      git reset --hard $sha
      git checkout $ref
      echo "Failed to gc, branch does not rebase cleanly."
    fi
  else
    echo "Working tree not clean, not doing anything."
  fi
}

_gc() {
    local branches
    branches=($(git for-each-ref --format='%(refname:short)' 'refs/heads/*'))
    _arguments "1: :($branches)"
}
compdef _gc gc

tail-gcp-instance() {
  case $1 in
    daml)
      local project=da-dev-gcp-daml-language
      ;;
    davl)
      local project=da-dev-pinacolada
      ;;
    *)
  esac
  local CURRENT_DATE_UTC=`date --utc -Iseconds`
  local FILE=$(mktemp)
  while true; do
    sleep 1
    gcloud logging read --project=$project "resource.type=gce_instance AND resource.labels.instance_id=$2 AND timestamp>=\"${CURRENT_DATE_UTC}\"" --format json | jq -r '.[] | .textPayload' > $FILE
    cat $FILE | sed '/^$/d'
    if [[ $(cat $FILE | head -n 5 | wc -l) -ne 0 ]]; then
      CURRENT_DATE_UTC=`date --utc -Iseconds`;
    fi
  done
}

refresh_machines() {
    machines=$(gcloud compute instances list --format=json --project=da-dev-gcp-daml-language | jq -c '[.[] | select (.name | startswith("ci-")) | {key: .name, value: .zone | sub (".*/"; "")}] | from_entries')
}

kill_machine() {
    if [ -z "$machines" ]; then
        refresh_machines
    fi
    for machine in $@; do
        gcloud -q compute instances --project=da-dev-gcp-daml-language delete --zone=$(echo $machines | jq -r ".[\"$machine\"]") $machine
    done
}
_kill_machine() {
    local machine_names
    if [ -z "$machines" ]; then
        refresh_machines
    fi
    machine_names=$(echo $machines | jq -r "keys - $(echo -n $words | jq -sRc 'split(" ")') | .[]")
    _arguments "*: :($machine_names)"
}
compdef _kill_machine kill_machine

if [ -e /Users/garyverhaegen/.nix-profile/etc/profile.d/nix.sh ]; then . /Users/garyverhaegen/.nix-profile/etc/profile.d/nix.sh; fi # added by Nix installer

git_large() (
    git rev-list --objects --all |
    git cat-file --batch-check='%(objecttype) %(objectname) %(objectsize) %(rest)' |
    sed -n 's/^blob //p' |
    sort --numeric-sort --key=2 |
    cut -c 1-12,41- |
    $(command -v gnumfmt || echo numfmt) --field=2 --to=iec-i --suffix=B --padding=7 --round=nearest
)

if [ -e $HOME/.nix-profile/etc/profile.d/nix.sh ]; then . $HOME/.nix-profile/etc/profile.d/nix.sh; fi # added by Nix installer

if [ -e /Users/gary/.nix-profile/etc/profile.d/nix.sh ]; then . /Users/gary/.nix-profile/etc/profile.d/nix.sh; fi # added by Nix installer
if [ -e /home/gary/.nix-profile/etc/profile.d/nix.sh ]; then . /home/gary/.nix-profile/etc/profile.d/nix.sh; fi # added by Nix installer
